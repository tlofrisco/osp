/**
 * ü§ñ Dynamic OSP Worker - Executes AI-Generated Workflows
 * 
 * This worker dynamically creates activities based on OpenAI-generated workflow definitions.
 * No hard-coded workflows - everything is driven by the service definition.
 */

import { Worker, NativeConnection } from '@temporalio/worker';
import { createTemporalConnection, generateTaskQueue } from '$lib/temporal/client';
import { supabaseAdmin } from '$lib/supabaseAdmin';
import type { WorkflowDefinition, WorkflowStep } from '$lib/types/workflow';

/**
 * Dynamic Activity Factory - Creates activities based on workflow definitions
 */
class DynamicActivityFactory {
  /**
   * Creates a generic activity executor that can handle any workflow step
   */
  static createActivity(stepDefinition: WorkflowStep) {
    return async (input: any) => {
      console.log(`üîÑ Executing step: ${stepDefinition.name}`);
      
      try {
        // Based on step type, execute different logic
        switch (stepDefinition.type) {
          case 'create_entity':
            return await this.createEntity(stepDefinition, input);
          
          case 'update_entity':
            return await this.updateEntity(stepDefinition, input);
          
          case 'validate':
            return await this.validateData(stepDefinition, input);
          
          case 'notify':
            return await this.sendNotification(stepDefinition, input);
          
          case 'calculate':
            return await this.performCalculation(stepDefinition, input);
          
          case 'check_availability':
            return await this.checkAvailability(stepDefinition, input);
          
          case 'activity':
          default:
            // Generic activity execution
            return await this.executeGenericActivity(stepDefinition, input);
        }
      } catch (error) {
        console.error(`‚ùå Step ${stepDefinition.name} failed:`, error);
        throw error;
      }
    };
  }

  /**
   * Creates a new entity in the database
   */
  private static async createEntity(step: WorkflowStep, input: any) {
    const entityName = step.target_entity?.toLowerCase() || 'reservation';
    
    // Generate a unique ID for the new entity
    const entityId = `${entityName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Prepare entity data based on input and step configuration
    const entityData: any = {
      id: entityId,
      workflow_state: 'created',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    // Map input fields to entity fields
    if (step.uses_fields && Array.isArray(step.uses_fields)) {
      for (const field of step.uses_fields) {
        if (input[field] !== undefined) {
          entityData[field] = input[field];
        }
      }
    }
    
    // Add default values for Reservation entities
    if (step.target_entity === 'Reservation') {
      entityData.status = entityData.status || 'pending';
      entityData.workflow_state = 'pending_confirmation';
      
      // Generate test data if no input provided (manual execution)
      if (Object.keys(input).length === 0 || !input.customer_name) {
        console.log('‚ö†Ô∏è No input provided - generating test data for workflow execution');
        entityData.customer_name = 'Test Customer ' + Date.now();
        entityData.phone_number = '555-' + Math.floor(Math.random() * 10000).toString().padStart(4, '0');
        entityData.reservation_date = new Date().toISOString();
        entityData.reservation_time = '19:00';
        entityData.party_size = 2;
        entityData.table_number = Math.floor(Math.random() * 20) + 1;
        entityData.special_requests = 'Generated by Temporal workflow';
      }
    }
    
    console.log(`üíæ Creating ${entityName} with data:`, entityData);
    
    // üî• USE RPC PATTERN (same as API endpoint)
    // Extract service schema from workflow context
    const serviceSchema = input.serviceSchema || input._serviceSchema || 'a_restaurant_reservation_syste_1749301938153';
    
    const { data: insertResult, error } = await supabaseAdmin
      .rpc('insert_into_dynamic_table', {
        in_schema_name: serviceSchema,
        in_table_name: entityName,
        json_data: entityData
      });
    
    if (error) {
      console.error(`Failed to create ${entityName}:`, error);
      throw new Error(`Failed to create ${entityName}: ${error.message}`);
    }
    
    console.log(`‚úÖ Created ${entityName} via RPC:`, insertResult);
    return { success: true, entityId: entityId, data: entityData };
  }

  /**
   * Updates an existing entity
   */
  private static async updateEntity(step: WorkflowStep, input: any) {
    const entityName = step.target_entity?.toLowerCase() || 'reservation';
    
    if (!input.entityId) {
      throw new Error('Entity ID is required for update operations');
    }

    const updateData: any = {};
    step.updates_fields?.forEach(field => {
      const fieldName = field.split('.').pop();
      if (fieldName) {
        // Use step configuration to determine value
        if (step.field_values && step.field_values[fieldName]) {
          updateData[fieldName] = step.field_values[fieldName];
        } else if (input[fieldName] !== undefined) {
          updateData[fieldName] = input[fieldName];
        }
      }
    });

    updateData.updated_at = new Date().toISOString();

    console.log(`üîÑ Updating ${entityName} ${input.entityId} with:`, updateData);

    // üî• USE RPC PATTERN FOR UPDATES
    // Extract service schema from workflow context
    const serviceSchema = input.serviceSchema || input._serviceSchema || 'a_restaurant_reservation_syste_1749301938153';
    
    // For updates, we'll use a generic update RPC or execute raw SQL
    const updateSql = `
      UPDATE "${serviceSchema}"."${entityName}" 
      SET ${Object.keys(updateData).map(key => `"${key}" = $${Object.keys(updateData).indexOf(key) + 2}`).join(', ')}
      WHERE id = $1
      RETURNING *;
    `;
    
    const { data, error } = await supabaseAdmin
      .rpc('execute_sql', {
        sql_text: updateSql
      });

    if (error) {
      console.error(`Failed to update ${entityName}:`, error);
      throw new Error(`Failed to update ${entityName}: ${error.message}`);
    }
    
    console.log(`‚úÖ Updated ${entityName}:`, input.entityId);
    return { success: true, data };
  }

  /**
   * Validates data according to step rules
   */
  private static async validateData(step: WorkflowStep, input: any) {
    const validationResults: any = { valid: true, errors: [] };

    // Execute validation rules from step definition
    if (step.validation_rules) {
      for (const rule of step.validation_rules) {
        const fieldValue = input[rule.field];
        
        switch (rule.type) {
          case 'required':
            if (!fieldValue) {
              validationResults.valid = false;
              validationResults.errors.push(`${rule.field} is required`);
            }
            break;
          
          case 'min_value':
            if (fieldValue < rule.value) {
              validationResults.valid = false;
              validationResults.errors.push(`${rule.field} must be at least ${rule.value}`);
            }
            break;
          
          case 'pattern':
            if (!new RegExp(rule.value).test(fieldValue)) {
              validationResults.valid = false;
              validationResults.errors.push(`${rule.field} format is invalid`);
            }
            break;
        }
      }
    }

    if (!validationResults.valid) {
      throw new Error(`Validation failed: ${validationResults.errors.join(', ')}`);
    }

    return validationResults;
  }

  /**
   * Sends notifications (placeholder for future implementation)
   */
  private static async sendNotification(step: WorkflowStep, input: any) {
    console.log(`üìß Sending notification: ${step.notification_type} to ${input.recipient}`);
    // In a real implementation, this would integrate with email/SMS services
    return { success: true, notificationId: `notif_${Date.now()}` };
  }

  /**
   * Performs calculations based on step configuration
   */
  private static async performCalculation(step: WorkflowStep, input: any) {
    let result = 0;
    
    if (step.calculation_type === 'sum') {
      result = step.calculation_fields?.reduce((sum, field) => {
        return sum + (input[field] || 0);
      }, 0) || 0;
    } else if (step.calculation_type === 'multiply') {
      result = step.calculation_fields?.reduce((product, field) => {
        return product * (input[field] || 1);
      }, 1) || 0;
    }

    return { result, calculation_type: step.calculation_type };
  }

  /**
   * Checks availability (e.g., for reservations, inventory)
   */
  private static async checkAvailability(step: WorkflowStep, input: any) {
    const entityName = step.target_entity?.toLowerCase() || 'reservation';
    
    console.log(`üîç Checking availability for ${entityName}`);

    // Extract service schema from workflow context
    const serviceSchema = input.serviceSchema || input._serviceSchema || 'a_restaurant_reservation_syste_1749301938153';
    
    // Build WHERE clause based on availability filters
    let whereClause = '';
    const filterValues: any[] = [];
    
    if (step.availability_filters) {
      const conditions: string[] = [];
      Object.entries(step.availability_filters).forEach(([field, value], index) => {
        const filterValue = value || input[field];
        if (filterValue !== undefined) {
          conditions.push(`"${field}" = $${index + 1}`);
          filterValues.push(filterValue);
        }
      });
      
      if (conditions.length > 0) {
        whereClause = 'WHERE ' + conditions.join(' AND ');
      }
    }

    // Use RPC to query the service schema
    const querySql = `SELECT * FROM "${serviceSchema}"."${entityName}" ${whereClause};`;
    
    console.log(`üîç Executing availability query: ${querySql}`);
    console.log(`üîç With values:`, filterValues);

    const { data, error } = await supabaseAdmin
      .rpc('execute_sql', {
        sql_text: querySql
      });

    if (error) {
      console.error(`Failed to check availability for ${entityName}:`, error);
      throw new Error(`Failed to check availability: ${error.message}`);
    }

    const conflicts = Array.isArray(data) ? data : [];
    const isAvailable = conflicts.length === 0;
    
    console.log(`‚úÖ Availability check result: ${isAvailable ? 'Available' : `${conflicts.length} conflicts found`}`);
    
    return { 
      available: isAvailable, 
      conflicts: conflicts,
      message: isAvailable ? 'Available' : `${conflicts.length} conflicts found`
    };
  }

  /**
   * Generic activity execution for custom logic
   */
  private static async executeGenericActivity(step: WorkflowStep, input: any) {
    console.log(`üîß Executing generic activity: ${step.name}`);
    
    // Log what fields are being used
    if (step.uses_fields?.length) {
      console.log(`  Using fields: ${step.uses_fields.join(', ')}`);
    }
    
    // Log what fields are being updated
    if (step.updates_fields?.length) {
      console.log(`  Updating fields: ${step.updates_fields.join(', ')}`);
    }

    // Return success with input data passed through
    return {
      success: true,
      step: step.name,
      input_data: input,
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Creates a dynamic workflow function from a workflow definition
 */
function createDynamicWorkflow(workflowDef: WorkflowDefinition) {
  return async function dynamicWorkflow(input: any) {
    console.log(`üöÄ Starting workflow: ${workflowDef.name}`);
    console.log(`üìã Input received:`, input);
    
    const results: any[] = [];
    let workflowState = 'in_progress';
    
    // Extract service schema from workflow ID or input
    const serviceSchema = input.serviceSchema || 
                         workflowDef.id.split('-')[0] || 
                         'a_restaurant_reservation_syste_1749301938153';
    
    console.log(`üèóÔ∏è Using service schema: ${serviceSchema}`);
    
    try {
      // Execute each step in sequence
      for (const step of workflowDef.steps) {
        console.log(`  üìç Step ${step.id}: ${step.name}`);
        
        // Add service schema to input for each step
        const stepInput = {
          ...input,
          serviceSchema: serviceSchema,
          _serviceSchema: serviceSchema // Backup reference
        };
        
        // Create and execute the activity for this step
        const activity = DynamicActivityFactory.createActivity(step);
        const stepResult = await activity(stepInput);
        
        results.push({
          stepId: step.id,
          stepName: step.name,
          result: stepResult
        });
        
        // Pass results to next step if needed
        if (stepResult.entityId) {
          input.entityId = stepResult.entityId;
        }
        if (stepResult.data) {
          input = { ...input, ...stepResult.data };
        }
      }
      
      workflowState = 'completed';
      console.log(`‚úÖ Workflow completed: ${workflowDef.name}`);
      
    } catch (error) {
      workflowState = 'failed';
      console.error(`‚ùå Workflow failed: ${workflowDef.name}`, error);
      throw error;
    }
    
    return {
      workflowId: workflowDef.id,
      workflowName: workflowDef.name,
      state: workflowState,
      results,
      serviceSchema: serviceSchema,
      completedAt: new Date().toISOString()
    };
  };
}

/**
 * Main worker startup - Updated for UUID-based manifest system
 */
export async function startDynamicWorker(serviceSchema: string) {
  console.log(`ü§ñ Starting Dynamic Worker for service: ${serviceSchema}`);
  console.log(`‚ö†Ô∏è Note: Consider using manifest UUID directly for better performance`);
  
  try {
    // üîç Use new UUID-based manifest system
    const { getLatestManifestForService } = await import('../../src/lib/manifestResolver');
    
    let workflows = [];
    
    // Try getting latest manifest from service_manifests table using new helper
    console.log(`üîç Fetching latest manifest for service: ${serviceSchema}`);
    const manifestData = await getLatestManifestForService(serviceSchema);
    
    if (manifestData && manifestData.manifest) {
      console.log(`‚úÖ Found manifest (${manifestData.version || 'unversioned'}) for service: ${serviceSchema}`);
      workflows = manifestData.manifest.workflows || [];
    } else {
      // Fallback: Try services table (legacy support)
      console.log('üìã No service manifest found, checking services table as fallback...');
      const { data: serviceData, error: serviceError } = await supabaseAdmin
        .from('services')
        .select('metadata')
        .eq('service_schema', serviceSchema)
        .single();
        
      if (serviceData && !serviceError) {
        workflows = serviceData.metadata?.workflows || [];
        console.log('üìã Using workflows from services.metadata (legacy fallback)');
      }
    }
    
    if (workflows.length === 0) {
      throw new Error(`No workflows found for service: ${serviceSchema}. Ensure the service has an active manifest.`);
    }
    
    console.log(`üìã Found ${workflows.length} workflows to register:`);
    workflows.forEach((workflow: any) => {
      console.log(`  ‚Ä¢ ${workflow.name} (${workflow.id})`);
    });
    
    // Create activities object
    const activities: Record<string, any> = {};
    const workflowsMap: Record<string, any> = {};
    
    workflows.forEach((workflow: WorkflowDefinition) => {
      // Create a wrapper that includes service context
      const workflowWithContext = createDynamicWorkflow(workflow);
      
      // Register workflow with service context
      workflowsMap[workflow.id] = async (input: any) => {
        return await workflowWithContext({
          ...input,
          serviceSchema: serviceSchema,
          _serviceSchema: serviceSchema
        });
      };
      
      // Register activities for each step
      workflow.steps.forEach(step => {
        const activityKey = `${workflow.id}_${step.id}`;
        activities[activityKey] = DynamicActivityFactory.createActivity(step);
        console.log(`  üìù Registered activity: ${activityKey}`);
      });
    });
    
    // üî• USE ACTUAL TEMPORAL CLOUD CONNECTION
    console.log('üåê Connecting to Temporal Cloud...');
    const connection = await createTemporalConnection();
    
    const taskQueue = generateTaskQueue(serviceSchema);
    console.log(`üìã Task Queue: ${taskQueue}`);
    
    // Create and start worker
    const worker = await Worker.create({
      connection,
      namespace: 'quickstart-osp.v5egj', // Your actual namespace
      taskQueue: taskQueue,
      workflows: workflowsMap,
      activities
    });
    
    console.log(`‚úÖ Worker started for task queue: ${taskQueue}`);
    console.log(`üåê Connected to Temporal Cloud namespace: quickstart-osp.v5egj`);
    console.log(`üì¶ Registered ${Object.keys(workflowsMap).length} workflows`);
    console.log(`‚öôÔ∏è Registered ${Object.keys(activities).length} activities`);
    console.log(`üéØ Service Schema: ${serviceSchema}`);
    
    await worker.run();
    
  } catch (error) {
    console.error('‚ùå Worker startup failed:', error);
    throw error;
  }
}

// Start worker if run directly
if (require.main === module) {
  const serviceSchema = process.argv[2];
  if (!serviceSchema) {
    console.error('Usage: node dynamicWorker.js <service_schema>');
    process.exit(1);
  }
  
  startDynamicWorker(serviceSchema).catch(err => {
    console.error('Worker error:', err);
    process.exit(1);
  });
} 